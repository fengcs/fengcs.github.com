<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二、感知机--统计机器学习方法]]></title>
    <url>%2F2017%2F10%2F14%2Ftj-perceptron%2F</url>
    <content type="text"><![CDATA[感知机模型 由输入空间到输出空间的如下函数称为感知机： f(x)=sign(w⋅x+b)f(x)=sign(w \cdot x+b) f(x)=sign(w⋅x+b) $ w\in R^n $ 叫做权值（weight），$ b\in R 叫做偏置（bias）， w \cdot x $是向量的内积，sign是符号函数，如下所示： sign(x)={+1,x≥0−1,x&lt;0sign(x)=\begin{cases}+1, &amp; x\geq 0 \\ -1, &amp; x&lt;0 \end{cases} sign(x)={​+1,​−1,​​​x≥0​x&lt;0​​ 感知机激励函数(激活函数) 激活函数是用来加入非线性因素的，若没有激活函数，多层的网络模型可累加为一层网络模型。 阶跃函数 sign(x)={+1,x≥0−1,x&lt;0sign(x)=\begin{cases}+1, &amp; x\geq 0 \\ -1, &amp; x&lt;0 \end{cases} sign(x)={​+1,​−1,​​​x≥0​x&lt;0​​ sigmoid函数 S(x)=11+e−xS(x)=\frac{1}{1+e^{-x}} S(x)=​1+e​−x​​​​1​​ S′(x)=S(x)∗(1−S(x))S&#x27;(x)= S(x)*(1-S(x)) S​′​​(x)=S(x)∗(1−S(x)) 感知机的学习策略 定义训练集： T={(x1,y1),(x2,y2),...,(xN,yN)}T=\{ (x_1,y_1),(x_2,y_2),...,(x_N,y_N) \} T={(x​1​​,y​1​​),(x​2​​,y​2​​),...,(x​N​​,y​N​​)} 其中$ x_i\in X=R^n $ ，$ y_i\in Y={+1, -1} $， $ i=1,2,…,N $，M为误分类点集合。感知机学习的损失函数定义为： L(W,b)=∑xi∈Myi(w⋅xi+b)L(W,b) = \sum_{x_i\in M} y_i(w \cdot x_i+b) L(W,b)=​x​i​​∈M​∑​​y​i​​(w⋅x​i​​+b) 感知机学习算法 感知机学习算法的原始形式 输入：训练数据集 $ T={ (x_1,y_1),(x_2,y_2),…,(x_N,y_N) } ，其中 x_i\in R^n $ ，$ y_i\in {+1, -1} $， $ i=1,2,…,N ，学习率 \eta(0 \leq \eta \leq1) $ 输出：$ w,b $； 感知机模型 $ f(x)=sign(w \cdot x+b) $ 选取初始值$ w_0,b_0 $ 在训练集中选取数据$ x_i,y_i $ 如果$ y_i(w \cdot x_i+b) \leq 0 $ w←w+ηyixi w \leftarrow w+\eta y_ix_i w←w+ηy​i​​x​i​​ b←b+ηyi b \leftarrow b+\eta y_i b←b+ηy​i​​ 转至2，直至训练集中没有误分类点 感知机学习算法的对偶形式 输入：训练数据集 $ T={ (x_1,y_1),(x_2,y_2),…,(x_N,y_N) } ，其中 x_i\in R^n $ ，$ y_i\in {+1, -1} $， $ i=1,2,…,N ，学习率 \eta(0 \leq \eta \leq1) $ 输出：$ \alpha,b $； 感知机模型 $ f(x)=sign(\sum_{j=1}^N \alpha_j y_j x_j \cdot x+b) ； 其中 \alpha=(\alpha_1,\alpha_2,…,\alpha_N )^T $，每一位为常数 选取初始值$ \alpha \leftarrow 0, b \leftarrow 0 $ 在训练集中选取数据$ x_i,y_i $ 如果$ y_i(\sum_{j=1}^N \alpha_j y_j x_j \cdot x_i+b) \leq 0 $ αi←αi+η \alpha_i \leftarrow \alpha_i+\eta α​i​​←α​i​​+η b←b+ηyi b \leftarrow b+\eta y_i b←b+ηy​i​​ 转至2，直至训练集中没有误分类点]]></content>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、统计机器学习概论--统计机器学习方法]]></title>
    <url>%2F2017%2F10%2F12%2Ftj-introduction%2F</url>
    <content type="text"><![CDATA[基本概念 监督学习：学习一个模型，使模型能对任意给定的输入，对其相应的输出做出一个很好的预测。 输入空间，输出空间 实例，特征向量，特征空间 回归问题：输入与输出变量均连续 分类问题：输出变量为有限的离散变量 标注问题：输入与输出均为变量序列 模型 模型就是所要学习的条件概率或决策函数 F={f∣Y=f(x)}F = \{ f | Y = f(x)\} F={f∣Y=f(x)} F={P∣P(Y∣X)}F=\{P|P(Y|X)\} F={P∣P(Y∣X)} 策略 常用损失函数： 0-1损失函数 L(Y,f(x))={1,Y≠f(x)0,Y=f(x)L(Y,f(x))=\begin{cases}1, &amp; Y \neq f(x)\\0, &amp; Y = f(x)\end{cases} L(Y,f(x))={​1,​0,​​​Y≠f(x)​Y=f(x)​​ 绝对损失函数 L(Y,F(x))=∣F−f(x)∣L(Y,F(x))=|F-f(x)| L(Y,F(x))=∣F−f(x)∣ 平方损失函数 L(Y,F(x))=(Y−f(x))2L(Y,F(x))=(Y-f(x))^2 L(Y,F(x))=(Y−f(x))​2​​ 对数损失函数 L(Y,F(x))=−logP(Y∣x)L(Y,F(x))=-logP(Y|x) L(Y,F(x))=−logP(Y∣x) 期望风险与经验风险 Rexp(f)≈Remp(f)=1N∑i=1NL(yi,f(xi))R_{exp}(f) \approx R_{emp}(f)=\frac{1}{N}\sum_{i=1}^N L(y_i,f(x_i)) R​exp​​(f)≈R​emp​​(f)=​N​​1​​​i=1​∑​N​​L(y​i​​,f(x​i​​)) 算法 统计问题归结为最优化问题，统计学习的算法为求解最优化问题， 过拟合 一味提高对训练数据的预测能力，所选模型的复杂度往往比真实模型高，这种现象称为过拟合。 正则化 在经验风险上加上一个正则化项或者罚项 minf∈F1N∑i=1NL(yi,f(xi))+λJ(f)\min_{f \in F} \frac{1}{N}\sum_{i=1}^N L(y_i,f(x_i))+\lambda J(f) ​f∈F​min​​​N​​1​​​i=1​∑​N​​L(y​i​​,f(x​i​​))+λJ(f) 如在回归问题中，取w的二范式或者一范式 minf∈F1N∑i=1NL(yi,f(xi))+λ2∣w∣2\min_{f \in F} \frac{1}{N}\sum_{i=1}^N L(y_i,f(x_i))+\frac{\lambda}{2} |w|^2 ​f∈F​min​​​N​​1​​​i=1​∑​N​​L(y​i​​,f(x​i​​))+​2​​λ​​∣w∣​2​​ minf∈F1N∑i=1NL(yi,f(xi))+λ∣w∣1\min_{f \in F} \frac{1}{N}\sum_{i=1}^N L(y_i,f(x_i))+\lambda |w|_1 ​f∈F​min​​​N​​1​​​i=1​∑​N​​L(y​i​​,f(x​i​​))+λ∣w∣​1​​ 交叉验证 随机的将样本分为训练集（training set），验证集（validation set）和测试集（test set）。 为解决样本不足情况： 简单交叉验证：训练集/测试集（7：3），选出测试误差最小的模型 N折交叉验证（N-fold cross valication）：将数据且分为N个不相交的子集，使用S-1个子集进行训练。 泛化能力 学习方法的泛化能力是指学习到的模型对位置数据的预测能力 生成式模型与判别式模型 生成式模型：由数据学习联合概率分布，然后求出条件概率密度作为预测模型。典型的有：朴素贝叶斯与隐马尔科夫模型 P(Y∣X)=P(X,Y)P(X)P(Y|X) = \frac{P(X,Y)}{P(X)} P(Y∣X)=​P(X)​​P(X,Y)​​ 判别式方法：由数据直接学习决策函数f(X)或者条件概率密度P(Y|X)作为预测函数。典型的有：logsitic回归/K邻近/感知机/决策树/最大熵/支持向量机/boosting/条件随机场 分类问题 精确率（precision）: P=TPTP+FPP = \frac{TP}{TP+FP} P=​TP+FP​​TP​​ 召回率（recall）: R=TPTP+FNR = \frac{TP}{TP+FN} R=​TP+FN​​TP​​ F1值： 2F1=1P+1R\frac{2}{F_1} = \frac{1}{P} +\frac{1}{R} ​F​1​​​​2​​=​P​​1​​+​R​​1​​ F1=2TP2TP+FP+FN{F_1} = \frac{2TP}{2TP+FP+FN} F​1​​=​2TP+FP+FN​​2TP​​ 另一个直观的图：]]></content>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boston_housing]]></title>
    <url>%2F2017%2F10%2F09%2Fboston-housing%2F</url>
    <content type="text"><![CDATA[数据集介绍与简单操作 数据集介绍 数据下载地址： https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data 共有506条样本，样本无序，共14列数据，如下，主要用于回归测试。 CRIM - 犯罪率（per capita crime rate by town） ZN - 住宅地占比（proportion of residential land zoned for lots over 25,000 sq.ft.） INDUS - 商业区占地比（proportion of non-retail business acres per town.） CHAS - 是否湖景房（Charles River dummy variable (1 if tract bounds river; 0 otherwise)） NOX - PM2.5值 (nitric oxides concentration (parts per 10 million)) RM - 公寓平均房间数（average number of rooms per dwelling） AGE - 老住宅比例（proportion of owner-occupied units built prior to 1940） DIS - 距离城区距离（weighted distances to five Boston employment centres） RAD - 距离高速距离（index of accessibility to radial highways） TAX - 个税税率（full-value property-tax rate per $10,000） PTRATIO - 学生教师比（pupil-teacher ratio by town） B - 黑人比（ 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town） LSTAT - 低收入人群比（ % lower status of the population） MEDV - 自住房均价（Median value of owner-occupied homes in $1000’s） 简单操作 12345678910111213141516171819202122from sklearn.datasets import load_bostonboston = load_boston()print(boston.keys())# 数据维度print(boston.data.shape)# 特征名称print(boston.feature_names)# 数据集描述print(boston.DESCR)# 目标维度print(boston.target.shape)bos = pd.DataFrame(boston.data)print(bos.head())bos.columns = boston.feature_namesbos['PRICE'] = boston.target# 前5行样本数据print(bos.head())# 数据集均值方差等统计print(bos.describe()) 输出如下： 线性回归基础 12345678910111213141516171819202122from sklearn.datasets import load_bostonfrom sklearn.linear_model import LinearRegressionX_train, X_test, Y_train, Y_test = sklearn.model_selection.train_test_split(X, Y, test_size=0.33, random_state=5)print(X_train.shape)print(X_test.shape)print(Y_train.shape)print(Y_test.shape)lm = LinearRegression()lm.fit(X_train, Y_train)Y_pred = lm.predict(X_test)plt.scatter(Y_test, Y_pred)plt.xlabel(&quot;Prices: $Y_i$&quot;)plt.ylabel(&quot;Predicted prices: $\hat&#123;Y&#125;_i$&quot;)plt.title(&quot;Prices vs Predicted prices: $Y_i$ vs $\hat&#123;Y&#125;_i$&quot;)plt.show()mse = sklearn.metrics.mean_squared_error(Y_test, Y_pred)print(mse) 程序输出如下： 参考： Linear Regression on Boston Housing 预测波士顿房价–机器学习工程师纳米学位]]></content>
  </entry>
  <entry>
    <title><![CDATA[zookeeper-introduction]]></title>
    <url>%2F2017%2F09%2F30%2Fzookeeper-introduction%2F</url>
    <content type="text"><![CDATA[参考 http://yuzhouwan.com/posts/31915/]]></content>
  </entry>
  <entry>
    <title><![CDATA[flume 基础入门]]></title>
    <url>%2F2017%2F09%2F30%2Fflume-introduction%2F</url>
    <content type="text"><![CDATA[Flume简介 Apache Flume是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统。目前，只能运行在Unix服务器上。 Flume基于流式数据的、使用简单的（借助配置文件即可）、健壮的、容错的。 Flume的简单体现在：写一个source、channel、sink之后，一条命令就能操作成功。 Flume、Kafka实时进行数据收集，Storm、Spark实时数据处理，Impala实时查询。 数据流框架 基本概念： Event：一个数据单元，带有一个可选的消息头。 Flow：Event从源点到达目的点的迁移的抽象。 Client：操作位于源点处的Event，将其发送到Flume Agent。 Agent：一个独立的Flume进程，包含组件Source、Channel、Sink。 Source：用来消费传递到该组件的Event ，存入channel中。 Channel：中转Event的一个临时存储，保存有Source组件传递过来的Event。 Sink：从Channel中读取并移除Event，将Event传递到Flow Pipeline中的下一个Agent（如果有的话）。 核心组件 Source ExecSource: 以运行 Linux 命令的方式，持续的输出最新的数据，如 tail -F 文件名 指令，在这种方式下，取的文件名必须是指定的。 ExecSource 可以实现对日志的实时收集，但是存在Flume不运行或者指令执行出错时，将无法收集到日志数据，无法保证日志数据的完整性。 SpoolSource: 监测配置的目录下新增的文件，并将文件中的数据读取出来。需要注意两点：拷贝到 spool 目录下的文件不可以再打开编辑；spool 目录下不可包含相应的子目录。SpoolSource无法实现实时的收集数据，但可以设置以分钟的方式分割文件，趋于实时。 Channel Memory Channel, JDBC Channel , File Channel，Psuedo Transaction Channel。比较常见的是前三种 channel。 Sink Flume安装 与使用 安装 1234567wget http://mirrors.tuna.tsinghua.edu.cn/apache/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz apache-flume-1.7.0-bin.tar.gztar -zxf flume-ng-1.5.0-cdh5.3.6.tar.gz# 配置Java环境，cat &quot;export JAVA_HOME=/XXX&quot; &gt;&gt; conf/flume-env.sh# 运行bin/flume-ng agent -n $agent_name -c conf -f conf/flume-conf.properties.template 参数说明： （1）agent参数表示，启动一个agent。 （2）-n或者–name 指定agent的名字，在配置文件中定义的agent的名称，例如下边的样例的名字是a1。 （3）-c或者–conf 指定配置文件所在的目录。该目录下要包含flume-env.sh文件。 （4）-f或者–conf-file 指定具体的配置文件。 -f指定的是一个Flume Agent的配置，存储在本地配置文件，该配置文件包含对source、channel、sink的属性配置，和其相关联形成数据流的配置。 Flume官方实例 配置文件 下面配置文件定义了一个agent，名为“a1”。a1有一个source，监听端口44444的数据。source、channel、sink的名称分别是r1、c1、k1。a1.channels.c1.type = memory 定义使用内存作为channel。 1234567891011121314151617181920212223# example.conf: A single-node Flume configuration#Name the components of the agent:a1.sources=r1a1.channels=c1a1.sinks=k1#Describe/Define the source:a1.sources.r1.type=netcata1.sources.r1.bind=hadoop-senior01.pmpa.coma1.sources.r1.port=44444#Describe/Define the channel:a1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 100# Describe the sinka1.sinks.k1.type = logger# Bind the source and sink to the channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动agent 1bin/flume-ng agent -n a1 -c conf -f conf/test-conf.properties -Dflume.root.logger=INFO,console todo! 参考 奉先 Flume介绍 Flume介绍]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo基本配置]]></title>
    <url>%2F2017%2F09%2F29%2Fhexo%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[官方网站提供了很好的文档，请首先查看：https://hexo.io/zh-cn/docs/index.html 初始化 123456npm install hexo-cli -g# npm install hexo --no-optional -ghexo init Blogcd Blognpm installhexo server 皮肤 github站点： https://github.com/iissnan/hexo-theme-next 相关文档：http://theme-next.iissnan.com/getting-started.html 1234567mkdir themes/nextcurl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1git tag -lgit checkout tags/v5.1.0# 修改_config.ymltheme: next 基本配置 12# 简体中文language: zh-Hans 写日志 基本操作 12hexo new [layout] &lt;title&gt; # layout: post/page/drafthexo publish draft &lt;title&gt; 添加图片 12post_asset_folder:truenpm install https://github.com/CodeFalling/hexo-asset-image --save 部署到github 1234567891011# 添加git依赖npm install hexo-deployer-git --save# 修改_config.ymldeploy: type: git repo: git@github.com:jiji262/jiji262.github.io.git branch: master# 部署hexo d/deploy 添加搜索 解决bug: https://github.com/iissnan/theme-next-docs/issues/162 安装步骤： http://theme-next.iissnan.com/third-party-services.html#algolia-search 常用命令 1234hexo algoliahexo shexo ghexo d]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
